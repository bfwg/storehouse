JVM回收算法
1、标记-清除
2、复制
3、标记-清除-压缩

JVM垃圾对象标记
1、引用计数
2、引用跟踪

垃圾收集器
现在java虚拟机的收集器都是把对象按其存活时间分为年轻代、年老代、永久代。然后采用上述
回收算法回收，主要收集器有：
1、串行收集器
2、并行收集器
3、并发收集器

JVM年代划分
Young （年轻代） 年轻代分三个区。一个 Eden 区，两个 Survivor 区。大部分对象在 Eden 区
                 中生成。当 Eden 区满时，还存活的对象将被复制到 Survivor 区（两个中的
		 一个），当这个 Survivor 区满时，此区的存活对象将被复制到另外一个 
		 Survivor 区，当这个 Survivor 去也满了的时候，从第一个 Survivor 区复
		 制过来的并且此时还存活的对象，将被复制 " 年老区 (Tenured)" 。需要注意
		 Survivor 的两个区是对称的，没先后关系，所以同一个区中可能同时存在从 
		 Eden 复制过来 对象，和从前一个 Survivor 复制过来的对象，而复制到年老区
		 的只有从第一个 Survivor 去过来的对象。而且， Survivor 区总有一个是空的。
Tenured（年老代）年老代存放从年轻代存活的对象。一般来说年老代存放的都是生命期较长的对象。
Perm （持久代）  用于存放静态文件，如今 Java 类、方法等。持久代对垃圾回收没有显著影响，
                 但是有些应用可能动态生成或者调用一些 class ，例如 Hibernate 等，在这种
		 时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代
		 大小通过 -XX:MaxPermSize= 进行设置。

GC 类型
GC 有两种类型： Scavenge GC 和 Full GC 。
Scavenge GC    一般情况下，当新对象生成，并且在 Eden 申请空间失败时，就好触发 Scavenge
                GC ，堆 Eden 区域进行 GC ，清除非存活对象，并且把尚且存活的对象移动到 
		Survivor 区。然后整理 Survivor 的两个区。只作用年轻代
Full GC        对整个堆进行整理，包括 Young 、 Tenured 和 Perm 。 Full GC 比 Scavenge GC
               要慢，因此应该尽可能减少 Full GC 。有如下原因可能导致 Full GC ：Tenured 被写满
               Perm 域被写满，System.gc() 被显示调用，上一次 GC 之后 Heap 的各域分配策略
	       动态变化

上述知识点详解
JVM回收算法
1、标记-清除   此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶
               段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。
2、复制        此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历
               当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理正在使
	       用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过
	       出现 " 碎片 " 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。
3、标记-清除-压缩  此算法结合了 " 标记 - 清除 " 和 " 复制 " 两个算法的优点。也是分两阶段，第
               一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且
	       把存活对象 " 压缩 " 到堆的其中一块，按顺序排放。此算法避免了 " 标记 - 清除 " 
	       的碎片问题，同时也避免了 " 复制 " 算法的空间问题。
JVM垃圾对象标记
1、引用计数    无法处理循环引用的问题
2、引用跟踪    此方法用来替代引用计数，解决引用计数存在的问题

垃圾收集器
                JVM 给了三种选择：串行收集器、并行收集器、并发收集器 ，但是串行收集器只适用于
		小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下， 
		JDK5.0 以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。 
		JDK5.0 以后， JVM 会根据当前系统配置进行判断。 
1、串行收集器  使用单线程处理所有垃圾回收工作，因为无需多线程交互，所以效率比较高。但是，也无
               法使用多处理器的优势，所以此收集器适合单处理器机器。当然，此收集器也可以用在小
	       数据量（ 100M 左右）情况下的多处理器机器上。可以使用 -XX:+UseSerialGC 打开。
2、并行收集器  
                对年轻代进行并行垃圾回收，因此可以减少垃圾回收时间。一般在多线程多处理器机器上使用。
		使用 -XX:+UseParallelGC. 打开。并行收集器在 J2SE5.0 第六 6 更新上引入，在 Java SE6.0
		中进行了增强 -- 可以堆年老代进行并行收集。如果年老代不使用并发收集的话，是使用单线程
		进行垃圾回收，因此会制约扩展能力。使用 -XX:+UseParallelOldGC 打开。
                使用 -XX:ParallelGCThreads= 设置并行垃圾回收的线程数。此值可以设置与机器处理器数量相等。
                此收集器可以进行如下配置：
                最大垃圾回收暂停 : 指定垃圾回收时的最长暂停时间，通过 -XX:MaxGCPauseMillis= 指定。 为毫秒 . 如果指定了此值的话，堆大小和垃圾回收相关参数会进行调整以达到指定值。设定此值可能会减少应用的吞吐量。
                吞吐量 : 吞吐量为垃圾回收时间与非垃圾回收时间的比值，通过 -XX:GCTimeRatio= 来设定，公式为 1/ （ 1+N ）。例如， -XX:GCTimeRatio=19 时，表示 5% 的时间用于垃圾回收。默认情况为 99 ，即 1% 的时间用于垃圾回收。
并发收集器      可以保证大部分工作都并发进行（应用不停止），垃圾回收只暂停很少的时间，此收集器适合对响应时间要求比较高的中、大规模应用。
                这种回收期不进行内存碎片整理，使用 -XX:+UseConcMarkSweepGC 打开。配合-XX:+UseCMSCompactAtFullCollection
                -XX:CMSFullGCsBeforeCompaction这两个指令使用

三种收集器的选择
串行处理器：
-- 适用情况：数据量比较小（ 100M 左右）；单处理器下并且对响应时间无要求的应用。
-- 缺点：只能用于小型应用
并行处理器：
-- 适用情况： " 对吞吐量有高要求 " ，多 CPU 、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。
-- 缺点：应用响应时间可能较长
并发处理器：
-- 适用情况： " 对响应时间有高要求 " ，多 CPU 、对应用响应时间有较高要求的中、大型应用。举例： Web 服务器 / 应用服务器、电信交换、集成开发环境。


典型配置
堆设置

    -Xms: 初始堆大小
    -Xmx: 最大堆大小
    -XX:NewSize=n: 设置年轻代大小
    -XX:NewRatio=n: 设置年轻代和年老代的比值。如 : 为 3 ，表示年轻代与年老代比值为 1 ： 3 ，年轻代占整个年轻代年老代和的 1/4
    -XX:SurvivorRatio=n: 年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如： 3 ，表示 Eden ： Survivor=3 ： 2 ，一个 Survivor 区占整个年轻代的 1/5
    -XX:MaxPermSize=n: 设置持久代大小
收集器设置
    -XX:+UseSerialGC: 设置串行收集器
    -XX:+UseParallelGC: 设置并行收集器,这个设置只能指定年轻代的收集器，年老代继续使用默认收集器
    -XX:+UseParalledlOldGC: 设置并行年老代收集器
    -XX:+UseConcMarkSweepGC: 设置并发收集器，这种回收器只对年老代起作用，年轻代使用默认值，也可通过-XX:+UseParNewGC指定年轻代为并行收集器
垃圾回收统计信息
    -XX:+PrintGC
    -XX:+PrintGCDetails
    -XX:+PrintGCTimeStamps
    -Xloggc:filename
并行收集器设置
    -XX:ParallelGCThreads=n: 设置并行收集器收集时使用的 CPU 数。并行收集线程数。
    -XX:MaxGCPauseMillis=n: 设置并行收集最大暂停时间
    -XX:GCTimeRatio=n: 设置垃圾回收时间占程序运行时间的百分比。公式为 1/(1+n)
并发收集器设置
    -XX:+CMSIncrementalMode: 设置为增量模式。适用于单 CPU 情况。
    -XX:ParallelGCThreads=n: 设置并发收集器年轻代收集方式为并行收集时，使用的 CPU 数。并行收集线程数。